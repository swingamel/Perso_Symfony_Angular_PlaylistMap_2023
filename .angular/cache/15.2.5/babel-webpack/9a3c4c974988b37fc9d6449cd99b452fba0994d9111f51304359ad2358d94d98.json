{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { catchError, forkJoin, from, map, Observable, switchMap, takeWhile } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class SpotifyService {\n  constructor(http) {\n    this.http = http;\n    this.apiUrl = 'https://mmi.unilim.fr/~morap01/L250/public/index.php/api';\n  }\n  getAlbums() {\n    return this.http.get(`${this.apiUrl}/albums`);\n  }\n  getAlbum(id) {\n    return from(fetch(`${this.apiUrl}/albums/${id}`).then(response => response.json()));\n  }\n  getSong(id) {\n    return this.http.get(`${this.apiUrl}/songs/${id}`);\n  }\n  searchSongs(query) {\n    return this.http.get(`${this.apiUrl}/songs?title=${query}`).pipe(map(response => {\n      if (Array.isArray(response)) {\n        return response;\n      } else {\n        return [response];\n      }\n    }));\n  }\n  searchArtists(query) {\n    return this.http.get(`${this.apiUrl}/artists?name=${query}`).pipe(map(response => {\n      if (Array.isArray(response)) {\n        return response;\n      } else {\n        return [response];\n      }\n    }));\n  }\n  searchAlbums(query) {\n    return this.http.get(`${this.apiUrl}/albums?title=${query}`).pipe(map(response => {\n      if (Array.isArray(response)) {\n        return response;\n      } else {\n        return [response];\n      }\n    }));\n  }\n  /*  searchPlaylists(keyword: string): Observable<Playlist[]> {\r\n      const url = `${this.apiUrl}/playlists?q=${keyword}`;\r\n      return this.http.get<Playlist[]>(url);\r\n    }*/\n  getArtistById(artistId) {\n    return this.http.get(`${this.apiUrl}/artists/${artistId}`);\n  }\n  getArtistAlbums(artistId, page) {\n    let params = new HttpParams().set('artistId', artistId.toString());\n    if (page) {\n      params = params.set('page', page.toString());\n    }\n    return this.getArtistById(artistId).pipe(switchMap(artist => {\n      // @ts-ignore\n      const albumRequests = artist.albums.map(album => fetch(album.url).then(response => response.arrayBuffer()));\n      return forkJoin(albumRequests).pipe(map(albumArrayBuffers => {\n        return albumArrayBuffers.map(albumBuffer => {\n          const albumJson = new TextDecoder().decode(albumBuffer);\n          return JSON.parse(albumJson);\n        });\n      }));\n    }));\n  }\n  getAllPlaylists(searchTerm) {\n    let id = 1;\n    const playlists = [];\n    return new Observable(observer => {\n      const getPlaylist = () => {\n        let params = new HttpParams();\n        if (searchTerm) {\n          params = params.append('q', searchTerm);\n        }\n        this.http.get(`${this.apiUrl}/playlists/${id}`, {\n          params\n        }).pipe(map(response => {\n          if (!searchTerm || response.name.toLowerCase().includes(searchTerm.toLowerCase())) {\n            playlists.push(response);\n          }\n          id++;\n          if (response.id) {\n            // continue the loop\n            getPlaylist();\n          } else {\n            observer.next(playlists);\n            observer.complete();\n          }\n        }), catchError(error => {\n          // stop the loop and return the playlists that have been fetched so far\n          observer.next(playlists);\n          observer.complete();\n          return [];\n        }), takeWhile(() => id < 1000) // limit the loop to a maximum of 1000 iterations\n        ).subscribe();\n      };\n      getPlaylist();\n    });\n  }\n}\nSpotifyService.ɵfac = function SpotifyService_Factory(t) {\n  return new (t || SpotifyService)(i0.ɵɵinject(i1.HttpClient));\n};\nSpotifyService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: SpotifyService,\n  factory: SpotifyService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["HttpParams","catchError","forkJoin","from","map","Observable","switchMap","takeWhile","SpotifyService","constructor","http","getAlbums","get","apiUrl","getAlbum","id","fetch","then","response","json","getSong","searchSongs","query","pipe","Array","isArray","searchArtists","searchAlbums","getArtistById","artistId","getArtistAlbums","page","params","set","toString","artist","albumRequests","albums","album","url","arrayBuffer","albumArrayBuffers","albumBuffer","albumJson","TextDecoder","decode","JSON","parse","getAllPlaylists","searchTerm","playlists","observer","getPlaylist","append","name","toLowerCase","includes","push","next","complete","error","subscribe","factory","providedIn"],"sourceRoot":"","sources":["C:\\IUT\\spotizer\\src\\app\\services\\spotify.service.ts"],"sourcesContent":["import {Injectable} from '@angular/core';\r\nimport {HttpClient, HttpParams} from '@angular/common/http';\r\nimport {catchError, forkJoin, from, map, Observable, switchMap, takeWhile} from 'rxjs';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class SpotifyService {\r\n\r\n  private apiUrl = 'https://mmi.unilim.fr/~morap01/L250/public/index.php/api';\r\n\r\n  constructor(private http: HttpClient) {\r\n  }\r\n\r\n  getAlbums(): Observable<Object> {\r\n    return this.http.get(`${this.apiUrl}/albums`);\r\n  }\r\n\r\n  getAlbum(id: number): Observable<any> {\r\n    return from(\r\n      fetch(`${this.apiUrl}/albums/${id}`)\r\n        .then(response => response.json())\r\n    );\r\n  }\r\n  getSong(id: number): Observable<any> {\r\n    return this.http.get(`${this.apiUrl}/songs/${id}`);\r\n  }\r\n\r\n\r\n  searchSongs(query: string): Observable<any> {\r\n    return this.http.get(`${this.apiUrl}/songs?title=${query}`).pipe(\r\n      map((response: any) => {\r\n        if (Array.isArray(response)) {\r\n          return response;\r\n        } else {\r\n          return [response];\r\n        }\r\n      })\r\n    );\r\n  }\r\n\r\n  searchArtists(query: string): Observable<any> {\r\n    return this.http.get(`${this.apiUrl}/artists?name=${query}`).pipe(\r\n      map((response: any) => {\r\n        if (Array.isArray(response)) {\r\n          return response;\r\n        } else {\r\n          return [response];\r\n        }\r\n      })\r\n    );\r\n  }\r\n\r\n  searchAlbums(query: string): Observable<any> {\r\n    return this.http.get(`${this.apiUrl}/albums?title=${query}`).pipe(\r\n      map((response: any) => {\r\n          if (Array.isArray(response)) {\r\n            return response;\r\n          } else {\r\n            return [response];\r\n          }\r\n        }\r\n      ));\r\n  }\r\n\r\n/*  searchPlaylists(keyword: string): Observable<Playlist[]> {\r\n    const url = `${this.apiUrl}/playlists?q=${keyword}`;\r\n    return this.http.get<Playlist[]>(url);\r\n  }*/\r\n\r\n  getArtistById(artistId: number): Observable<Artist> {\r\n    return this.http.get<Artist>(`${this.apiUrl}/artists/${artistId}`);\r\n  }\r\n\r\n  getArtistAlbums(artistId: number, page?: number): Observable<Album[]> {\r\n    let params = new HttpParams().set('artistId', artistId.toString());\r\n    if (page) {\r\n      params = params.set('page', page.toString());\r\n    }\r\n\r\n    return this.getArtistById(artistId).pipe(\r\n      switchMap(artist => {\r\n        // @ts-ignore\r\n        const albumRequests = artist.albums.map(album => fetch(album.url).then(response => response.arrayBuffer()));\r\n        return forkJoin(albumRequests).pipe(\r\n          map(albumArrayBuffers => {\r\n            return albumArrayBuffers.map(albumBuffer => {\r\n              const albumJson = new TextDecoder().decode(albumBuffer);\r\n              return JSON.parse(albumJson) as Album;\r\n            });\r\n          })\r\n        );\r\n      })\r\n    );\r\n  }\r\n\r\n\r\n  getAllPlaylists(searchTerm?: string): Observable<any> {\r\n    let id = 1;\r\n    const playlists: any[] = [];\r\n\r\n    return new Observable(observer => {\r\n      const getPlaylist = () => {\r\n        let params = new HttpParams();\r\n        if (searchTerm) {\r\n          params = params.append('q', searchTerm);\r\n        }\r\n        this.http.get(`${this.apiUrl}/playlists/${id}`, { params }).pipe(\r\n          map((response: any) => {\r\n            if (!searchTerm || response.name.toLowerCase().includes(searchTerm.toLowerCase())) {\r\n              playlists.push(response);\r\n            }\r\n            id++;\r\n            if (response.id) {\r\n              // continue the loop\r\n              getPlaylist();\r\n            } else {\r\n              observer.next(playlists);\r\n              observer.complete();\r\n            }\r\n          }),\r\n          catchError(error => {\r\n            // stop the loop and return the playlists that have been fetched so far\r\n            observer.next(playlists);\r\n            observer.complete();\r\n            return [];\r\n          }),\r\n          takeWhile(() => id < 1000) // limit the loop to a maximum of 1000 iterations\r\n        ).subscribe();\r\n      };\r\n\r\n      getPlaylist();\r\n    });\r\n  }\r\n}\r\n\r\nexport interface Album {\r\n  id: number;\r\n  title: string;\r\n  image: string;\r\n  artist: Artist;\r\n}\r\n\r\nexport interface Playlist {\r\n  id: number;\r\n  name: string;\r\n  songs: Song[];\r\n}\r\n\r\nexport interface Song {\r\n  id: number;\r\n  title: string;\r\n  length: number;\r\n  youtube : string;\r\n}\r\n\r\nexport interface Artist {\r\n  id: number;\r\n  name: string;\r\n  songs: Song[];\r\n  albums: Album[];\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}